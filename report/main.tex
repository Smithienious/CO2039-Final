\documentclass[a4paper]{article}

% Global layout
\usepackage{fancyhdr, graphicx, hyperref, indentfirst, lastpage, setspace}
\usepackage[margin=40mm]{geometry}

% Encoding
\usepackage[utf8]{vntex, inputenc} % vntex first to avoid Vietnamese auto-captions
\usepackage{amsmath, amssymb, gensymb}

% Better table
\usepackage{array, booktabs, multicol, multirow, siunitx}

% Code space
\usepackage[dvipsnames]{xcolor}
\usepackage{tikz}
\usepackage[framemethod=tikz]{mdframed}
\usepackage{minted, verbatim} % needs --shell-escape flag and Pygments

% Graphics
\usepackage{caption, float}

% Page setup
% \allowdisplaybreaks{} % to have page breaks inside align* environment
\hypersetup{urlcolor=blue,linkcolor=black,citecolor=red,colorlinks=true}
\usemintedstyle{emacs}
\numberwithin{equation}{section}
% \renewcommand{\arraystretch}{1.2} % space between table rows

% Global style setup
\makeatletter % change font size for not having underfull hbox
\renewcommand\Huge{\@setfontsize\Huge{22pt}{18}}
\makeatother

\AtBeginDocument{\renewcommand*\contentsname{Contents}}
\AtBeginDocument{\renewcommand*\refname{References}}
\setlength{\headheight}{40pt}
\pagestyle{fancy}
\fancyhead{} % clear all header fields
\fancyhead[L]{
  \begin{tabular}{rl}
    \begin{picture}(25,15)(0,0)
    \put(0,-8){\includegraphics[width=8mm, height=8mm]{hcmut.png}}
    \end{picture}
    \begin{tabular}{l}
      \textbf{\bf \ttfamily University of Technology, Ho Chi Minh City}\\
      \textbf{\bf \ttfamily Faculty of Computer Science and Engineering}
    \end{tabular}
  \end{tabular}
}
\fancyhead[R]{
	\begin{tabular}{l}
		\tiny \bf \\
		\tiny \bf
	\end{tabular}  }
\fancyfoot{} % clear all footer fields
\fancyfoot[L]{\scriptsize \ttfamily Report for Advanced Programming --- Academic year 2020--2021}
\fancyfoot[R]{\scriptsize \ttfamily Page {\thepage}/\pageref{LastPage}}
\renewcommand{\headrulewidth}{0.3pt}
\renewcommand{\footrulewidth}{0.3pt}

% \everymath{\color{blue}}

\newcommand*\mean[1]{\bar{#1}}
\newenvironment{code}[1]
{\VerbatimEnvironment%
  \begin{mdframed}[leftline=false,rightline=false,backgroundcolor=magenta!10,nobreak=false]%
    \begin{minted}[linenos=true,breaklines,breaksymbolleft=,obeytabs=true,tabsize=2]{#1}%
}
{
    \end{minted}%
  \end{mdframed}%
}
\newenvironment{console}
{\VerbatimEnvironment%
  \begin{mdframed}[leftline=false,rightline=false,backgroundcolor=teal!10,nobreak=false]%
    \begin{minted}[linenos=true,breaklines,breaksymbolleft=,obeytabs=true,tabsize=2]{text}%
}
{
    \end{minted}%
  \end{mdframed}%
}

\begin{document}

\begin{titlepage}
  \begin{center}
    VIETNAM NATIONAL UNIVERSITY, HO CHI MINH CITY \\
    UNIVERSITY OF TECHNOLOGY \\
    FACULTY OF COMPUTER SCIENCE AND ENGINEERING
  \end{center}

  \vspace{1cm}

  \begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{hcmut.png}
  \end{figure}

  \vspace{1cm}

  \begin{center}
    \begin{tabular}{c}
      \textbf{\Large Advanced Programming (CO2039)}             \\
      {}                                                        \\
      \midrule                                                  \\
      \textbf{\Large Report (Semester 202, Duration: 01 weeks)} \\
      {}                                                        \\
      \textbf{\Huge OOP vs FP}                                  \\
      {}                                                        \\
      \bottomrule
    \end{tabular}
  \end{center}

  \vspace{3cm}

  \begin{table}[h]
    \begin{tabular}{rl}
      \hspace{1cm} Advisor:      & Mr.\ Lê Lam Sơn \\
                                 &                 \\
      \hspace{1cm} Student Name: & Nguyễn Hoàng    \\
      \hspace{1cm} Student ID\@: & 1952255         \\
    \end{tabular}
  \end{table}

  \begin{center}
    {\footnotesize HO CHI MINH CITY, AUGUST 2021}
  \end{center}
\end{titlepage}


% \thispagestyle{empty}

% \newpage
% \tableofcontents
% \newpage

\section{OOP and FP in baking a pizza}
OOP makes code understandable by encapsulating moving parts.
FP makes code understandable by minimizing moving parts.

What? Alright that sounds a bit rough, let's rephrase this a bit.
OOP aims to model the world in self-contained entities, and affects change by modifying the state of itself or other entities.
FP on the other hand aims to not modify the original data, but rather creates new data given some existing data.

To demonstrate this, we will try to make a pizza.
With OOP, a big box or object with all the materials to create a pizza is available, and the helper methods will slowly transform them into a complete pizza.
FP will take a different approach, as materials are given to each stage/step/activity in order to be used in the next activity until the final product is achieved.

We will try to describe this pizza making progress programmatically using C++ and Haskell.

Let's start with a complete C++ program
\begin{code}{C}
#include <iostream>
#include <string>

class Pastry
{
public:
  virtual void bake_me_baby()
  {
    prepare_dough();
    add_sauce();
    add_toppings();
    bake();
  }

protected:
  virtual void prepare_dough() = 0;
  virtual void add_sauce() = 0;
  virtual void add_toppings() = 0;
  virtual void bake() = 0;
};

class Pizza : public Pastry
{
protected:
  int time = 0;
  std::string state = "Raw";

protected:
  void prepare_dough()
  {
    if (time != 0)
      return;
    time = 1;
    state = "Prepared dough";
  }
  void add_sauce()
  {
    if (time != 1)
      return;
    time = 2;
    state = "Added sauce";
  }
  void add_toppings()
  {
    if (time != 2)
      return;
    time = 3;
    state = "Added toppings";
  }
  void bake()
  {
    if (time != 3)
      return;
    time = 4;
    state = "Baked the hell out of this";
  }

public:
  void bake_me_baby()
  {
    prepare_dough();
    std::cout << state << std::endl;
    add_sauce();
    std::cout << state << std::endl;
    add_toppings();
    std::cout << state << std::endl;
    bake();
    std::cout << state << std::endl;
  }
};

int main(int argc, char **argv)
{
  Pastry *pizza = new Pizza();
  pizza->bake_me_baby();
  delete pizza;
  return 0;
}
\end{code}

Output of this program
\begin{console}
>>> g++ -g main.cpp -o main && ./main
1 Prepared dough
2 Added sauce
3 Added toppings
4 Baked the hell out of this
\end{console}

Nice! Let's do this again, but with Haskell
\begin{code}{Haskell}
module Main (main) where

data Pizza = Pizza {time :: Int, state :: String} deriving (Show)

prepareDough :: Pizza -> Pizza
prepareDough pizza@(Pizza t _)
  | t /= 0 = pizza
  | otherwise = pizza {time = 1, state = "Prepared dough"}

addSauce :: Pizza -> Pizza
addSauce pizza@(Pizza t _)
  | t /= 1 = pizza
  | otherwise = pizza {time = 2, state = "Added sauce"}

addToppings :: Pizza -> Pizza
addToppings pizza@(Pizza t _)
  | t /= 2 = pizza
  | otherwise = pizza {time = 3, state = "Added toppings"}

bake :: Pizza -> Pizza
bake pizza@(Pizza t _)
  | t /= 3 = pizza
  | otherwise = pizza {time = 4, state = "Baked the hell out of this"}

bakeMeBaby :: Pizza -> IO ()
bakeMeBaby pizza = do
  let pizza1 = prepareDough pizza
  print pizza1
  let pizza2 = addSauce pizza1
  print pizza2
  let pizza3 = addToppings pizza2
  print pizza3
  let pizza4 = bake pizza3
  print pizza4

main :: IO ()
main = do
  let pizza = Pizza 0 "Raw"
  bakeMeBaby pizza
\end{code}

Output of this program
\begin{console}
>>> ghc -g main.hs -o main && ./main
[1 of 1] Compiling Main             ( main.hs, main.o )
Linking main ...
Pizza {time = 1, state = "Prepared dough"}
Pizza {time = 2, state = "Added sauce"}
Pizza {time = 3, state = "Added toppings"}
Pizza {time = 4, state = "Baked the hell out of this"}
\end{console}

\section{Comparing the pizza-making methods}
With the pizza making out of the way, there are definitely some things noticeable between the two approaches.
Obviously, the procedure of the process does not change, but the way the materials or the pizza, otherwise known as the data, are handled and processed is different.
Considering the context of this report, this is what I concluded

\begin{center}
  \begin{tabular}{*{3}{l}}
    \toprule
         & OOP & FP \\
    \cmidrule(lr){2-3}
    Pros &     &    \\
    Cons &     &    \\
    \bottomrule
  \end{tabular}
\end{center}

\section*{Easter egg}

\end{document}
